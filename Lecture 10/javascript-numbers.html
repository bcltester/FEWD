<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>JavaScript Numbers</title>
    <link href="assets/core.css" rel="stylesheet">
</head>
<body>
<div id="page-content">
  
  <section class="chapter" title="Chapter 11. Numbers" epub:type="chapter" id="numbers"><div class="titlepage"><div><div>
    <h2 class="title">JavaScript&nbsp;Numbers</h2></div></div></div><p>JavaScript has<a id="ix_numbers11" class="indexterm"> a single type for all numbers: it treats all of them as floating-point numbers. </a><a id="id1109860" class="indexterm">However, the dot is not displayed if there are no digits after the decimal point:</a></p><pre class="screen">&gt; 5.000
5</pre><p>Internally, most JavaScript engines optimize and do distinguish between floating-point numbers and integers (details: <a class="xref" href="http://speakingjs.com/es5/ch11.html#integers" title="Integers in JavaScript">Integers in JavaScript</a>).<a id="id1109871" class="indexterm"> But that is something that programmers don’t see.</a></p><p>JavaScript numbers are <code class="literal">double</code> (64-bit) values, based on the IEEE Standard for Floating-Point Arithmetic (IEEE 754).<a id="id1109899" class="indexterm"> That standard is used by many programming languages.</a></p><div class="sect1" title="Number Literals"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_number_literals">Number Literals</h2></div></div></div><p>A number literal can <a id="id1139817" class="indexterm"></a><a id="id1139825" class="indexterm">be an integer, floating point, or (integer) hexadecimal:</a></p><pre class="screen">&gt; 35  // integer
35
&gt; 3.141  // floating point
3.141
&gt; 0xFF  // hexadecimal
255</pre><div class="sect2" title="Exponent"><div class="titlepage"><div><div><h3 class="title" id="_exponent">Exponent</h3></div></div></div><p>An exponent, <code class="literal">eX</code>, is an abbreviation<a id="id1149403" class="indexterm"></a><a id="id1149410" class="indexterm"> for “multiply with 10<sup>X</sup>”:</a></p><pre class="screen">&gt; 5e2
500
&gt; 5e-2
0.05
&gt; 0.5e2
50</pre></div><div class="sect2" title="Invoking Methods on Literals"><div class="titlepage"><div><div><h3 class="title" id="_invoking_methods_on_literals">Invoking Methods on Literals</h3></div></div></div><p>With number literals, the <a id="id1149445" class="indexterm"></a><a id="id1077823" class="indexterm">dot for accessing a property must be distinguished from the decimal dot. This leaves you with the following options if you want to invoke <code class="literal">toString()</code> on the number literal <code class="literal">123</code>:</a></p><pre class="programlisting"><code class="mi">123</code><code class="p">..</code><code class="nx">toString</code><code class="p">()</code>
<code class="mi">123</code> <code class="p">.</code><code class="nx">toString</code><code class="p">()</code>  <code class="c1">// space before the dot</code>
<code class="mf">123.0</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code>
<code class="p">(</code><code class="mi">123</code><code class="p">).</code><code class="nx">toString</code><code class="p">()</code></pre></div></div><div class="sect1" title="Converting to Number"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="tonumber">Converting to Number</h2></div></div></div><p>Values are<a id="id1107948" class="indexterm"> converted to numbers as follows:</a></p><div class="informaltable"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> Value          </td><td style="border-bottom: 0.5pt solid ; "> Result</td></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">undefined</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">NaN</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">null</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">0</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A boolean</p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">false</code> → <code class="literal">0</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">true</code> → <code class="literal">1</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A number</p></td><td style="border-bottom: 0.5pt solid ; "><p>Same as input (nothing to convert)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A string</p></td><td style="border-bottom: 0.5pt solid ; "><p>Parse the number in the string (ignoring leading and trailing whitespace); the empty string is converted to 0.
    Example: <code class="literal">'3.141'</code> → <code class="literal">3.141</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>An object</p></td><td><p>Call <code class="literal">ToPrimitive(value, Number)</code> (see <a class="xref" href="http://speakingjs.com/es5/ch08.html#toprimitive" title="Algorithm: ToPrimitive()—Converting a Value to a Primitive">Algorithm: ToPrimitive()—Converting a Value to a Primitive</a>) and convert<a id="id1170544" class="indexterm"> the resulting primitive.</a></p></td></tr></tbody></table></div><p>When converting the empty string to a number, <code class="literal">NaN</code> would arguably be a better result.<a id="id1091309" class="indexterm"></a><a id="id1091312" class="indexterm"> The result 0 was chosen to help with empty numeric input fields, in line with what other programming languages did in the mid-1990s.<sup>[</sup></a><a id="id1121023" href="http://speakingjs.com/es5/ch11.html#ftn.id1121023" class="footnote">14</a>]</p><div class="sect2" title="Manually Converting to Number"><div class="titlepage"><div><div><h3 class="title" id="_manually_converting_to_number">Manually Converting to Number</h3></div></div></div><p>The two <a id="id1121026" class="indexterm"></a><a id="id1121034" class="indexterm">most common ways to convert any value to a number are:</a></p><div class="informaltable"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Number(value)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>(Invoked as a function, not as a constructor)</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">+value</code></p></td><td><p></p></td></tr></tbody></table></div><p>I prefer <code class="literal">Number()</code>, because it is more descriptive. Here are some examples:</p><pre class="screen">&gt; Number('')
0
&gt; Number('123')
123
&gt; Number('\t\v\r12.34\n ')  // ignores leading and trailing whitespace
12.34

&gt; Number(false)
0
&gt; Number(true)
1</pre></div><div class="sect2" title="parseFloat()"><div class="titlepage"><div><div><h3 class="title" id="parseFloat">parseFloat()</h3></div></div></div><p>The global <a id="id1162940" class="indexterm">function <code class="literal">parseFloat()</code> provides another way to convert values to numbers. However, <code class="literal">Number()</code> is usually a better choice, as we shall see in a moment. This code:</a></p><pre class="programlisting"><code class="nb">parseFloat</code><code class="p">(</code><code class="nx">str</code><code class="p">)</code></pre><p>converts <code class="literal">str</code> to string, trims leading whitespace, and then parses the longest prefix that is a floating-point number.<a id="id1162981" class="indexterm"> If no such prefix exists (e.g., in an empty string), <code class="literal">NaN</code> is returned.</a></p><p>Comparing <code class="literal">parseFloat()</code> and <code class="literal">Number()</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
Applying <code class="literal">parseFloat()</code> to a nonstring is less efficient, because it coerces its argument to a string before parsing it. As a consequence, many values that <code class="literal">Number()</code> converts to actual numbers are converted to <code class="literal">NaN</code> by <code class="literal">parseFloat()</code>:
</p><pre class="screen">&gt; parseFloat(true)  // same as parseFloat('true')
NaN
&gt; Number(true)
1

&gt; parseFloat(null)  // same as parseFloat('null')
NaN
&gt; Number(null)
0</pre></li><li class="listitem"><p class="simpara">
<code class="literal">parseFloat()</code> parses the empty string as <code class="literal">NaN</code>:
</p><pre class="screen">&gt; parseFloat('')
NaN
&gt; Number('')
0</pre></li><li class="listitem"><p class="simpara">
<code class="literal">parseFloat()</code> parses until the last legal character, meaning you get a result where you may not want one:
</p><pre class="screen">&gt; parseFloat('123.45#')
123.45
&gt; Number('123.45#')
NaN</pre></li><li class="listitem"><p class="simpara">
<code class="literal">parseFloat()</code> ignores leading whitespace and stops before illegal characters (which include whitespace):
</p><pre class="screen">&gt; parseFloat('\t\v\r12.34\n ')
12.34</pre><p class="simpara"><code class="literal">Number()</code> ignores both leading and trailing whitespace (but other illegal characters lead to <code class="literal">NaN</code>).</p></li></ul></div></div></div><div class="sect1" title="Special Number Values"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_special_number_values">Special Number Values</h2></div></div></div><p>JavaScript has several <a id="id1180776" class="indexterm">special number values:</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
Two error values, <code class="literal">NaN</code> and <code class="literal">Infinity</code>.
</li><li class="listitem">
Two values for zero, <code class="literal">+0</code> and <code class="literal">-0</code>. JavaScript has two zeros, a positive zero and a negative zero, because the sign and the magnitude of a number are stored separately. In most of this book, I pretend that there is only a single zero, and you almost never see in JavaScript that there are two of them.
</li></ul></div><div class="sect2" title="NaN"><div class="titlepage"><div><div><h3 class="title" id="nan">NaN</h3></div></div></div><p>The error <a id="id1112617" class="indexterm"></a><a id="id1112623" class="indexterm"></a><a id="id1112634" class="indexterm">value <code class="literal">NaN</code> (an abbreviation for “not a number”) is, ironically, a number value:</a></p><pre class="screen">&gt; typeof NaN
'number'</pre><p>It is produced by errors such as the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
A number could not be parsed:
</p><pre class="screen">&gt; Number('xyz')
NaN
&gt; Number(undefined)
NaN</pre></li><li class="listitem"><p class="simpara">
An operation failed:
</p><pre class="screen">&gt; Math.acos(2)
NaN
&gt; Math.log(-1)
NaN
&gt; Math.sqrt(-1)
NaN</pre></li><li class="listitem"><p class="simpara">
One of the operands is <code class="literal">NaN</code> (this ensures that, if an error occurs during a longer computation, you can see it in the final result):
</p><pre class="screen">&gt; NaN + 3
NaN
&gt; 25 / NaN
NaN</pre></li></ul></div><div class="sect3" title="Pitfall: checking whether a value is NaN"><div class="titlepage"><div><div><h4 class="title" id="isNaN">Pitfall: checking whether a value is NaN</h4></div></div></div><p><code class="literal">NaN</code> is the only value <a id="id1055952" class="indexterm"></a><a id="id1055961" class="indexterm"></a><a id="id1053873" class="indexterm">that is not equal to itself:</a></p><pre class="screen">&gt; NaN === NaN
false</pre><p>Strict equality (<code class="literal">===</code>) is also used by <code class="literal">Array.prototype.indexOf</code>. You therefore can’t search for <code class="literal">NaN</code> in an array via that method:</p><pre class="screen">&gt; [ NaN ].indexOf(NaN)
-1</pre><p>If you want to check whether a value is <code class="literal">NaN</code>, you have to use the global<a id="id1053913" class="indexterm"> function <code class="literal">isNaN()</code>:</a></p><pre class="screen">&gt; isNaN(NaN)
true
&gt; isNaN(33)
false</pre><p>However, <code class="literal">isNaN</code> does not work properly with nonnumbers, because it first converts those to numbers. That conversion can produce <code class="literal">NaN</code> and then the function incorrectly returns <code class="literal">true</code>:</p><pre class="screen">&gt; isNaN('xyz')
true</pre><p>Thus, it is best to combine <code class="literal">isNaN</code> with a <a id="id458652" class="indexterm">type check:</a></p><pre class="programlisting"><code class="kd">function</code> <code class="nx">myIsNaN</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">typeof</code> <code class="nx">value</code> <code class="o">===</code> <code class="s1">'number'</code> <code class="o">&amp;&amp;</code> <code class="nb">isNaN</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
<code class="p">}</code></pre><p>Alternatively, you can check whether the value is unequal to itself (as <code class="literal">NaN</code> is the only value with this trait). But that is less <a id="id1182487" class="indexterm">self-explanatory:</a></p><pre class="programlisting"><code class="kd">function</code> <code class="nx">myIsNaN</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">value</code> <code class="o">!==</code> <code class="nx">value</code><code class="p">;</code>
<code class="p">}</code></pre><p>Note that this behavior is dictated by IEEE 754. As noted in Section 7.11, “Details of comparison predicates”:<sup>[<a id="id1174193" href="http://speakingjs.com/es5/ch11.html#ftn.id1174193" epub:type="noteref" class="footnote">15</a>]</sup></p><div class="blockquote"><blockquote class="blockquote"><p>Every NaN shall compare unordered with everything, including itself.</p></blockquote></div></div></div><div class="sect2" title="Infinity"><div class="titlepage"><div><div><h3 class="title" id="infinity">Infinity</h3></div></div></div><p><code class="literal">Infinity</code> is an error value indicating one<a id="id1158512" class="indexterm"></a><a id="id1158519" class="indexterm"> of two problems: a number can’t be represented because its magnitude is too large, or a division by zero has happened.</a></p><p><code class="literal">Infinity</code> is larger than any other number (except <code class="literal">NaN</code>). Similarly, <code class="literal">-Infinity</code> is smaller than any other number (except <code class="literal">NaN</code>). That makes them useful as default values—for example, when you are looking for a minimum or maximum.</p><div class="sect3" title="Error: a number’s magnitude is too large"><div class="titlepage"><div><div><h4 class="title" id="_error_a_number_s_magnitude_is_too_large">Error: a number’s magnitude is too large</h4></div></div></div><p>How large a number’s magnitude <a id="id1147783" class="indexterm">can become is determined by its internal representation (as discussed in </a><a class="xref" href="http://speakingjs.com/es5/ch11.html#number_representation" title="The Internal Representation of Numbers">The Internal Representation of Numbers</a>), which is the arithmetic product of:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
A mantissa (a binary number 1.f<sub>1</sub>f<sub>2</sub>...)
</li><li class="listitem">
2 to the power of an exponent
</li></ul></div><p>The exponent must be between (and excluding) −1023 and 1024. If the exponent is too small, the number becomes 0. If the exponent is too large, it becomes <code class="literal">Infinity</code>. 2<sup>1023</sup> can still be represented, but 2<sup>1024</sup> can’t:</p><pre class="screen">&gt; Math.pow(2, 1023)
8.98846567431158e+307
&gt; Math.pow(2, 1024)
Infinity</pre></div><div class="sect3" title="Error: division by zero"><div class="titlepage"><div><div><h4 class="title" id="_error_division_by_zero">Error: division by zero</h4></div></div></div><p>Dividing by <a id="id1095277" class="indexterm"></a><a id="id1095284" class="indexterm">zero produces <code class="literal">Infinity</code> as an error value:</a></p><pre class="screen">&gt; 3 / 0
Infinity
&gt; 3 / -0
-Infinity</pre></div><div class="sect3" title="Computing with Infinity"><div class="titlepage"><div><div><h4 class="title" id="_computing_with_infinity">Computing with Infinity</h4></div></div></div><p>You get the <a id="id1110726" class="indexterm">error result <code class="literal">NaN</code> if you try to “neutralize” one <code class="literal">Infinity</code> with another one:</a></p><pre class="screen">&gt; Infinity - Infinity
NaN
&gt; Infinity / Infinity
NaN</pre><p>If you try to go beyond <code class="literal">Infinity</code>, you still get <code class="literal">Infinity</code>:</p><pre class="screen">&gt; Infinity + Infinity
Infinity
&gt; Infinity * Infinity
Infinity</pre></div><div class="sect3" title="Checking for Infinity"><div class="titlepage"><div><div><h4 class="title" id="isFinite">Checking for Infinity</h4></div></div></div><p>Strict and lenient equality <a id="id1151175" class="indexterm"></a><a id="id1151184" class="indexterm">work fine for <code class="literal">Infinity</code>:</a></p><pre class="screen">&gt; var x = Infinity;
&gt; x === Infinity
true</pre><p>Additionally, the global function <code class="literal">isFinite()</code> allows<a id="id1151210" class="indexterm"> you to check whether a value is an actual number (neither infinite nor <code class="literal">NaN</code>):</a></p><pre class="screen">&gt; isFinite(5)
true
&gt; isFinite(Infinity)
false
&gt; isFinite(NaN)
false</pre></div></div><div class="sect2" title="Two Zeros"><div class="titlepage"><div><div><h3 class="title" id="two_zeros">Two Zeros</h3></div></div></div><p>Because JavaScript’s numbers keep <a id="ix_numbersJSzero" class="indexterm"></a><a id="ix_signedzero" class="indexterm"></a><a id="ix_number0" class="indexterm"></a><a id="ix_zeros" class="indexterm">magnitude and sign separate, each nonnegative number has a negative, including <code class="literal">0</code>.</a></p><p>The rationale for this is that whenever you represent a number digitally, it can become so small that it is indistinguishable from 0, because the encoding is not precise enough to represent the difference. Then a signed zero allows you to record “from which direction” you approached zero; that is, what sign the number had before it was considered zero. Wikipedia nicely sums up the pros and cons of <a class="ulink" href="http://en.wikipedia.org/wiki/Signed_zero" target="_top">signed zeros</a>:</p><div class="blockquote"><blockquote class="blockquote"><p>It is claimed that the inclusion of signed zero in IEEE 754 makes it much easier to achieve numerical accuracy in some critical problems, in particular when computing with complex elementary functions. On the other hand, the concept of signed zero runs contrary to the general assumption made in most mathematical fields (and in most mathematics courses) that negative zero is the same thing as zero. Representations that allow negative zero can be a source of errors in programs, as software developers do not realize (or may forget) that, while the two zero representations behave as equal under numeric comparisons, they are different bit patterns and yield different results in some operations.</p></blockquote></div><div class="sect3" title="Best practice: pretend there’s only one zero"><div class="titlepage"><div><div><h4 class="title" id="_best_practice_pretend_there_s_only_one_zero">Best practice: pretend there’s only one zero</h4></div></div></div><p>JavaScript goes to great lengths to hide the fact that there are two zeros. Given that it normally doesn’t matter that they are different, it is recommended that you play along with the illusion of the single zero. Let’s examine how that illusion is maintained.</p><p>In JavaScript, you normally write <code class="literal">0</code>, which means <code class="literal">+0</code>. But <code class="literal">-0</code> is also displayed as simply <code class="literal">0</code>. This is what you see when you use a browser command line or the Node.js REPL:</p><pre class="screen">&gt; -0
0</pre><p>That is because the standard <code class="literal">toString()</code> method converts <a id="id1104496" class="indexterm">both zeros to the same <code class="literal">'0'</code>:</a></p><pre class="screen">&gt; (-0).toString()
'0'
&gt; (+0).toString()
'0'</pre><p>Equality doesn’t distinguish <a id="id569999" class="indexterm">zeros, either. Not even <code class="literal">===</code>:</a></p><pre class="screen">&gt; +0 === -0
true</pre><p><code class="literal">Array.prototype.indexOf</code> uses <code class="literal">===</code> to search for elements, maintaining the illusion:</p><pre class="screen">&gt; [ -0, +0 ].indexOf(+0)
0
&gt; [ +0, -0 ].indexOf(-0)
0</pre><p>The ordering operators also consider the zeros to be equal:</p><pre class="screen">&gt; -0 &lt; +0
false
&gt; +0 &lt; -0
false</pre></div><div class="sect3" title="Distinguishing the two zeros"><div class="titlepage"><div><div><h4 class="title" id="_distinguishing_the_two_zeros">Distinguishing the two zeros</h4></div></div></div><p>How <span class="emphasis"><em>can</em></span> you <a id="id1132031" class="indexterm"></a><a id="id1132041" class="indexterm">actually observe that the two zeros are different? You can divide by zero (<code class="literal">-Infinity</code> and <code class="literal">+Infinity</code> <span class="emphasis"><em>can</em></span> be distinguished by <code class="literal">===</code>):</a></p><pre class="screen">&gt; 3 / -0
-Infinity
&gt; 3 / +0
Infinity</pre><p>Another way to perform<a id="id1159558" class="indexterm"> the division by zero is via <code class="literal">Math.pow()</code> (see </a><a class="xref" href="http://speakingjs.com/es5/ch21.html#Math.pow" title="Numerical Functions">Numerical Functions</a>):</p><pre class="screen">&gt; Math.pow(-0, -1)
-Infinity
&gt; Math.pow(+0, -1)
Infinity</pre><p><code class="literal">Math.atan2()</code> (see <a class="xref" href="http://speakingjs.com/es5/ch21.html#Math.atan2" title="Trigonometric Functions">Trigonometric Functions</a>) also<a id="id1159590" class="indexterm"> reveals that the zeros are different:</a></p><pre class="screen">&gt; Math.atan2(-0, -1)
-3.141592653589793
&gt; Math.atan2(+0, -1)
3.141592653589793</pre><p>The canonical way of telling the two zeros apart is the division by zero. Therefore, a function for detecting negative zeros would look <a id="id1140651" class="indexterm">like this:</a></p><pre class="programlisting"><code class="kd">function</code> <code class="nx">isNegativeZero</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">x</code> <code class="o">===</code> <code class="mi">0</code> <code class="o">&amp;&amp;</code> <code class="p">(</code><code class="mi">1</code><code class="o">/</code><code class="nx">x</code> <code class="o">&lt;</code> <code class="mi">0</code><code class="p">);</code>
<code class="p">}</code></pre><p>Here is the function in use:</p><pre class="screen">&gt; isNegativeZero(0)
false
&gt; isNegativeZero(-0)
true
&gt; isNegativeZero(33)
false</pre><p><a id="id572620" class="indexterm"></a><a id="id572628" class="indexterm"></a><a id="id572636" class="indexterm"></a><a id="id572642" class="indexterm"></a></p></div></div></div><div class="sect1" title="The Internal Representation of Numbers"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="number_representation">The Internal Representation of Numbers</h2></div></div></div><p>JavaScript numbers have 64-bit precision, which is also called <span class="emphasis"><em>double precision</em></span> (type <code class="literal">double</code> in some programming languages).<a id="id1053191" class="indexterm"></a><a id="id1053197" class="indexterm"></a><a id="id1053202" class="indexterm"> The internal representation is based on the IEEE 754 standard. The 64 bits are distributed between a number’s sign, exponent, and fraction</a><a id="id1053212" class="indexterm"></a><a id="id1053218" class="indexterm"> as follows:</a></p><div class="informaltable"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><td style="border-right: 0.5pt solid ; "> Sign  </td><td style="border-right: 0.5pt solid ; "> Exponent
∈ [−1023, 1024] </td><td> Fraction</td></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; "><p>1 bit</p></td><td style="border-right: 0.5pt solid ; "><p>11 bits</p></td><td><p>52 bits</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Bit 63</p></td><td style="border-right: 0.5pt solid ; "><p>Bits 62–52</p></td><td><p>Bits 51–0</p></td></tr></tbody></table></div><p>The value of a number is computed by the following formula:</p><p class="indentmath">(–1)<sup>sign</sup> × %1.fraction × 2<sup>exponent</sup></p><p>The prefixed percentage sign (<code class="literal">%</code>) means that the number in the middle is written in binary notation: a 1, followed by a binary point, followed by a binary fraction—namely the binary digits of the fraction (a natural number).<a id="id1089608" class="indexterm"> Here are some examples of this representation:</a></p><div class="informaltable"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>+0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p></p></td><td style="border-bottom: 0.5pt solid ; "><p>(sign = 0, fraction = 0, exponent = −1023)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>–0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p></p></td><td style="border-bottom: 0.5pt solid ; "><p>(sign = 1, fraction = 0, exponent = −1023)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>= (−1)<sup>0</sup> × %1.0 × 2<sup>0</sup></p></td><td style="border-bottom: 0.5pt solid ; "><p>(sign = 0, fraction = 0, exponent = 0)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>= (−1)<sup>0</sup> × %1.0 × 2<sup>1</sup></p></td><td style="border-bottom: 0.5pt solid ; "><p></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>= (−1)<sup>0</sup> × %1.1 × 2<sup>1</sup></p></td><td style="border-bottom: 0.5pt solid ; "><p>(sign = 0, fraction = 2<sup>51</sup>, exponent = 0)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0.5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>= (−1)<sup>0</sup> × %1.0 × 2<sup>−1</sup></p></td><td style="border-bottom: 0.5pt solid ; "><p></p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>−1</p></td><td style="border-right: 0.5pt solid ; "><p>= (−1)<sup>1</sup> × %1.0 × 2<sup>0</sup></p></td><td><p></p></td></tr></tbody></table></div><p>The encodings of +0, −0, and 3 can be explained as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
±0: Given that the fraction is always prefixed by a 1, it’s impossible to represent 0 with it. Hence, JavaScript encodes a zero via the fraction 0 and the special exponent −1023. The sign can be either positive or negative, meaning that JavaScript has two zeros (see <a class="xref" href="http://speakingjs.com/es5/ch11.html#two_zeros" title="Two Zeros">Two Zeros</a>).
</li><li class="listitem">
3: Bit 51 is the most significant (highest) bit of the fraction. That bit is 1.
</li></ul></div><div class="sect2" title="Special Exponents"><div class="titlepage"><div><div><h3 class="title" id="_special_exponents">Special Exponents</h3></div></div></div><p>The previously mentioned representation<a id="id1067152" class="indexterm"></a><a id="id1067166" class="indexterm"> of numbers is called <span class="emphasis"><em>normalized</em></span>.</a><a id="id1067179" class="indexterm"> In that case, the exponent <span class="emphasis"><em>e</em></span> is in the range −1023 &lt; <span class="emphasis"><em>e</em></span> &lt; 1024 (excluding lower and upper bounds).
−1023 and 1024 are special exponents:</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
1024 is used for error values such as <code class="literal">NaN</code> and <code class="literal">Infinity</code>.
</li><li class="listitem"><p class="simpara">
−1023 is used for:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
Zero (if the fraction is 0, as just explained)
</li><li class="listitem">
Small numbers close to zero (if the fraction is not 0).
</li></ul></div><p class="simpara">To enable both applications, a different, <a id="id1125031" class="indexterm">so-called <span class="emphasis"><em>denormalized</em></span>, representation is used:</a></p><p class="indentmath">(–1)<sup>sign</sup> × %0.fraction × 2<sup>–1022</sup></p><p class="simpara">To compare, the smallest (as in “closest to zero”) numbers in normalized representation are:</p><p class="indentmath">(–1)<sup>sign</sup> × %1.fraction × 2<sup>–1022</sup></p><p class="simpara">Denormalized numbers are smaller, because there is no leading digit 1.</p></li></ul></div></div></div><div class="sect1" title="Handling Rounding Errors"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="rounding_errors">Handling Rounding Errors</h2></div></div></div><p>JavaScript’s numbers are usually entered as decimal floating-point numbers, but they are internally represented as binary floating-point numbers.<a id="id1135582" class="indexterm"></a><a id="id1135592" class="indexterm"> That leads to imprecision. To understand why, let’s forget JavaScript’s internal storage format and take a general look at what fractions can be well represented by decimal floating-point numbers and by binary floating-point numbers. In the decimal system, all fractions are a mantissa <span class="emphasis"><em>m</em></span> divided by a power of 10:</a></p><div class="informalequation" style="width: auto"><div class="mediaobject"><span class="sm" style="height: 1.25em !important; display: inline-block;"><img style="width: auto; height: 1.25em !important; display: inline-block;" src="assets/eq_1101.png" class="sm" alt="" width="32.5" height="34.5"></span></div></div><p>So, in the denominator, there are only tens. That’s why <span class="inlinemediaobject"><span class="sm" style="height: 1.25em !important; display: inline-block;"><img src="assets/inleq_1102.png" class="sm" style="height: 1.25em !important; display: inline-block;" alt="" width="6" height="15.5"></span></span> cannot be expressed precisely as a decimal floating-point number—there is no way to get a 3 into the denominator. Binary floating-point numbers only have twos in the denominator. Let’s examine which decimal floating-point numbers can be represented well as binary and which can’t. If there are only twos in the denominator, the decimal number can be represented:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
0.5<sub>dec</sub> = <span class="inlinemediaobject"><span class="sm" style="height: 1.25em !important; display: inline-block;"><img src="assets/inleq_1103.png" class="sm" style="height: 1.25em !important; display: inline-block;" alt="" width="10.5" height="15"></span></span> = <span class="inlinemediaobject"><img src="assets/inleq_1104.png" alt="" width="6" height="15"></span> = 0.1<sub>bin</sub>
</li><li class="listitem">
0.75<sub>dec</sub> = <span class="inlinemediaobject"><img src="assets/inleq_1105.png" alt="" width="15" height="15"></span> = <span class="inlinemediaobject"><img src="assets/inleq_1106.png" alt="" width="6" height="15.5"></span> = 0.11<sub>bin</sub>
</li><li class="listitem">
0.125<sub>dec</sub> = <span class="inlinemediaobject"><img src="assets/inleq_1107.png" alt="" width="19" height="15"></span> = <span class="inlinemediaobject"><img src="assets/inleq_1108.png" alt="" width="6" height="15.5"></span> = 0.001<sub>bin</sub>
</li></ul></div><p>Other fractions cannot be represented precisely, because they have numbers other than 2 in the denominator (after prime factorization):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
0.1<sub>dec</sub> = <span class="inlinemediaobject"><img src="assets/inleq_1109.png" alt="" width="10.5" height="15"></span> = <span class="inlinemediaobject"><img src="assets/inleq_1110.png" alt="" width="21" height="15"></span>
</li><li class="listitem">
0.2<sub>dec</sub> = <span class="inlinemediaobject"><img src="assets/inleq_1111.png" alt="" width="10.5" height="15"></span> = <span class="inlinemediaobject"><img src="assets/inleq_1112.png" alt="" width="5.5" height="14.5"></span>
</li></ul></div><p>You can’t normally see that JavaScript doesn’t store exactly 0.1 internally. But you can make it visible by multiplying it with a high enough power of 10:</p><pre class="screen">&gt; 0.1 * Math.pow(10, 24)
1.0000000000000001e+23</pre><p>And if you add two imprecisely represented numbers, the result is sometimes imprecise enough that the imprecision becomes visible:</p><pre class="screen">&gt; 0.1 + 0.2
0.30000000000000004</pre><p>Another example:</p><pre class="screen">&gt; 0.1 + 1 - 1
0.10000000000000009</pre><p>Due to rounding errors, as a best practice you should not compare nonintegers directly. Instead, take an upper bound for rounding errors into consideration. Such an upper bound is called a <a class="ulink" href="http://en.wikipedia.org/wiki/Machine_epsilon" target="_top"><span class="emphasis"><em>machine epsilon</em></span></a>. The standard<a id="id1063548" class="indexterm"></a><a id="id1167823" class="indexterm"> epsilon value for double precision is 2<sup>−53</sup>:</a></p><pre class="programlisting"><code class="kd">var</code> <code class="nx">EPSILON</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">pow</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="o">-</code><code class="mi">53</code><code class="p">);</code>
<code class="kd">function</code> <code class="nx">epsEqu</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">abs</code><code class="p">(</code><code class="nx">x</code> <code class="o">-</code> <code class="nx">y</code><code class="p">)</code> <code class="o">&lt;</code> <code class="nx">EPSILON</code><code class="p">;</code>
<code class="p">}</code></pre><p><code class="literal">epsEqu()</code> ensures correct results where a normal comparison would be inadequate:</p><pre class="screen">&gt; 0.1 + 0.2 === 0.3
false
&gt; epsEqu(0.1+0.2, 0.3)
true</pre></div><div class="sect1" title="Integers in JavaScript"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="integers">Integers in JavaScript</h2></div></div></div><p>As mentioned before, JavaScript has only floating-point numbers. <a id="id1143146" class="indexterm"></a><a id="id570408" class="indexterm">Integers appear internally in two ways. First, most JavaScript engines store a small enough number without a decimal fraction as an integer (with, for example, 31 bits) and maintain that representation as long as possible. They have to switch back to a floating-point representation if a number’s magnitude grows too large or if a decimal fraction appears.</a></p><p>Second, the ECMAScript specification has integer operators: namely, all of the bitwise operators.<a id="id550357" class="indexterm"> Those operators convert their operands to 32-bit integers and</a><a id="id1143165" class="indexterm"> return 32-bit integers. For the specification, <span class="emphasis"><em>integer</em></span> only means that the numbers don’t have a decimal fraction, and <span class="emphasis"><em>32-bit</em></span> means that they are within a certain range. For engines, <span class="emphasis"><em>32-bit integer</em></span> means that an actual integer (non-floating-point) representation can usually be introduced or maintained.</a></p><div class="sect2" title="Ranges of Integers"><div class="titlepage"><div><div><h3 class="title" id="_ranges_of_integers">Ranges of Integers</h3></div></div></div><p>Internally, the following ranges of integers are <a id="id1143193" class="indexterm"></a><a id="id1143189" class="indexterm">important in JavaScript:</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
Safe integers (see <a class="xref" href="http://speakingjs.com/es5/ch11.html#safe_integers" title="Safe Integers">Safe Integers</a>), the largest practically usable range of integers that JavaScript supports:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
53 bits plus a sign, range (−2<sup>53</sup>,&nbsp;2<sup>53</sup>)
</li></ul></div></li><li class="listitem"><p class="simpara">
Array indices (see <a class="xref" href="http://speakingjs.com/es5/ch18.html#array_indices" title="Array Indices">Array Indices</a>):
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
32 bits, unsigned
</li><li class="listitem">
Maximum length: 2<sup>32</sup>−1
</li><li class="listitem">
Range of indices: [0,&nbsp;2<sup>32</sup>−1) (excluding the maximum length!)
</li></ul></div></li><li class="listitem"><p class="simpara">
Bitwise operands (see <a class="xref" href="http://speakingjs.com/es5/ch11.html#bitwise_operators" title="Bitwise Operators">Bitwise Operators</a>):
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
Unsigned right shift operator (<code class="literal">&gt;&gt;&gt;</code>): 32 bits, unsigned, range [0,&nbsp;2<sup>32</sup>)
</li><li class="listitem">
All other bitwise operators: 32 bits, including a sign, range [−2<sup>31</sup>,&nbsp;2<sup>31</sup>)
</li></ul></div></li><li class="listitem"><p class="simpara">
“Char codes,” UTF-16 code units as numbers:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
Accepted by <code class="literal">String.fromCharCode()</code> (see <a class="xref" href="http://speakingjs.com/es5/ch12.html#String.fromCharCode" title="String Constructor Method">String Constructor Method</a>)
</li><li class="listitem">
Returned by <code class="literal">String.prototype.charCodeAt()</code> (see <a class="xref" href="http://speakingjs.com/es5/ch12.html#String.prototype.charCodeAt" title="Extract Substrings">Extract Substrings</a>)
</li><li class="listitem">
16 bits, unsigned
</li></ul></div></li></ul></div></div><div class="sect2" title="Representing Integers as Floating-Point Numbers"><div class="titlepage"><div><div><h3 class="title" id="_representing_integers_as_floating_point_numbers">Representing Integers as Floating-Point Numbers</h3></div></div></div><p>JavaScript <a id="id1108368" class="indexterm"></a><a id="id1108378" class="indexterm">can only handle integer values up to a magnitude of 53 bits (the 52 bits of the fraction plus 1 indirect bit, via the exponent; see </a><a class="xref" href="http://speakingjs.com/es5/ch11.html#number_representation" title="The Internal Representation of Numbers">The Internal Representation of Numbers</a> for details).</p><p>The following table explains how JavaScript represents 53-bit integers as floating-point numbers:</p><div class="informaltable"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><td style="border-bottom: 0.5pt solid ; "> Bits    </td><td style="border-bottom: 0.5pt solid ; "> Range           </td><td style="border-bottom: 0.5pt solid ; "> Encoding</td></tr></thead><tbody><tr><td style="border-bottom: 0.5pt solid ; "><p>1 bit</p></td><td style="border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "><p>(See <a class="xref" href="http://speakingjs.com/es5/ch11.html#number_representation" title="The Internal Representation of Numbers">The Internal Representation of Numbers</a>.)</p></td></tr><tr><td style="border-bottom: 0.5pt solid ; "><p>1 bit</p></td><td style="border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>%1 × 2<sup>0</sup></p></td></tr><tr><td style="border-bottom: 0.5pt solid ; "><p>2 bits</p></td><td style="border-bottom: 0.5pt solid ; "><p>2–3</p></td><td style="border-bottom: 0.5pt solid ; "><p>%1.f<sub>51</sub> × 2<sup>1</sup></p></td></tr><tr><td style="border-bottom: 0.5pt solid ; "><p>3 bits</p></td><td style="border-bottom: 0.5pt solid ; "><p>4–7 = 2<sup>2</sup>–(2<sup>3</sup>−1)</p></td><td style="border-bottom: 0.5pt solid ; "><p>%1.f<sub>51</sub>f<sub>50</sub> × 2<sup>2</sup></p></td></tr><tr><td style="border-bottom: 0.5pt solid ; "><p>4 bits</p></td><td style="border-bottom: 0.5pt solid ; "><p>2<sup>3</sup>–(2<sup>4</sup>−1)</p></td><td style="border-bottom: 0.5pt solid ; "><p>%1.f<sub>51</sub>f<sub>50</sub>f<sub>49</sub> × 2<sup>3</sup></p></td></tr><tr><td style="border-bottom: 0.5pt solid ; "><p>⋯</p></td><td style="border-bottom: 0.5pt solid ; "><p>⋯</p></td><td style="border-bottom: 0.5pt solid ; "><p>⋯</p></td></tr><tr><td><p>53 bits</p></td><td><p>2<sup>52</sup>–(2<sup>53</sup>−1)</p></td><td><p>%1.f<sub>51</sub>⋯f<sub>0</sub> × 2<sup>52</sup></p></td></tr></tbody></table></div><p>There is no fixed sequence of bits that represents the integer. Instead, the mantissa %1.f is shifted by the exponent, so that the leading digit 1 is in the right place.
In a way, the exponent counts the number of digits of the fraction that are in active use (the remaining digits are 0). That means that for 2 bits, we use one digit of the fraction and for 53 bits, we use all digits of the fraction. Additionally, we can represent 2<sup>53</sup> as %1.0 × 2<sup>53</sup>, but we get problems with higher numbers:</p><div class="informaltable"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><td style="border-bottom: 0.5pt solid ; "> Bits    </td><td style="border-bottom: 0.5pt solid ; "> Range           </td><td style="border-bottom: 0.5pt solid ; "> Encoding</td></tr></thead><tbody><tr><td style="border-bottom: 0.5pt solid ; "><p>54 bits</p></td><td style="border-bottom: 0.5pt solid ; "><p>2<sup>53</sup>–(2<sup>54</sup>−1)</p></td><td style="border-bottom: 0.5pt solid ; "><p>%1.f<sub>51</sub>⋯f<sub>0</sub>0 × 2<sup>53</sup></p></td></tr><tr><td style="border-bottom: 0.5pt solid ; "><p>55 bits</p></td><td style="border-bottom: 0.5pt solid ; "><p>2<sup>54</sup>–(2<sup>55</sup>−1)</p></td><td style="border-bottom: 0.5pt solid ; "><p>%1.f<sub>51</sub>⋯f<sub>0</sub>00 × 2<sup>54</sup></p></td></tr><tr><td><p>⋯</p></td><td><p></p></td><td><p></p></td></tr></tbody></table></div><p>For 54 bits, the least significant digit is always 0, for 55 bits the two least significant digits are always 0, and so on. That means that for 54 bits, we can only represent every second number, for 55 bits only every fourth number, and so on. For example:</p><pre class="screen">&gt; Math.pow(2, 53) - 1  // OK
9007199254740991
&gt; Math.pow(2, 53)  // OK
9007199254740992
&gt; Math.pow(2, 53) + 1  // can't be represented
9007199254740992
&gt; Math.pow(2, 53) + 2  // OK
9007199254740994</pre><div class="sect3" title="Best practice"><div class="titlepage"><div><div><h4 class="title" id="_best_practice">Best practice</h4></div></div></div><p>If you work with integers of up to 53 bits magnitude, you are fine.<a id="id1072503" class="indexterm"> Unfortunately, you’ll often encounter 64-bit unsigned integers in programming (Twitter IDs, databases, etc.). These must be stored in strings in JavaScript. If you want to perform arithmetic with such integers, you need special libraries. There are plans to bring larger integers to JavaScript, but that will take a while.</a></p></div></div><div class="sect2" title="Safe Integers"><div class="titlepage"><div><div><h3 class="title" id="safe_integers">Safe Integers</h3></div></div></div><p>JavaScript can only safely represent integers <span class="emphasis"><em>i</em></span> in the range −2<sup>53</sup> &lt; <span class="emphasis"><em>i</em></span> &lt; 2<sup>53</sup>. <a id="id1072513" class="indexterm">This section examines what that means and what the consequences are. It is based on an </a><a class="ulink" href="http://mzl.la/1oOaCOO" target="_top">email by Mark S. Miller to the es-discuss mailing list</a>.</p><p>The idea of a safe integer centers on how mathematical integers are represented in JavaScript.
In the range (−2<sup>53</sup>, 2<sup>53</sup>) (excluding the lower and upper bounds), JavaScript integers are <span class="emphasis"><em>safe</em></span>: there is a one-to-one mapping between mathematical integers and their representations in JavaScript.</p><p>Beyond this range, JavaScript integers are <span class="emphasis"><em>unsafe</em></span>: two or more mathematical integers are represented as the same JavaScript integer. For example, starting at 2<sup>53</sup>, JavaScript can represent only every second mathematical integer (the previous section explains why). Therefore, a safe JavaScript integer is one that unambiguously represents a single mathematical integer.</p><div class="sect3" title="Definitions in ECMAScript 6"><div class="titlepage"><div><div><h4 class="title" id="_definitions_in_ecmascript_160_6">Definitions in ECMAScript&nbsp;6</h4></div></div></div><p>ECMAScript&nbsp;6 will <a id="id1175913" class="indexterm">provide the following constants:</a></p><pre class="programlisting"><code class="nb">Number</code><code class="p">.</code><code class="nx">MAX_SAFE_INTEGER</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">pow</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="mi">53</code><code class="p">)</code><code class="o">-</code><code class="mi">1</code><code class="p">;</code>
<code class="nb">Number</code><code class="p">.</code><code class="nx">MIN_SAFE_INTEGER</code> <code class="o">=</code> <code class="o">-</code><code class="nb">Number</code><code class="p">.</code><code class="nx">MAX_SAFE_INTEGER</code><code class="p">;</code></pre><p>It will also provide a function for determining whether <a id="id538069" class="indexterm">an integer is safe:</a></p><pre class="programlisting"><code class="nb">Number</code><code class="p">.</code><code class="nx">isSafeInteger</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">n</code> <code class="o">===</code> <code class="s1">'number'</code> <code class="o">&amp;&amp;</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">round</code><code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="o">===</code> <code class="nx">n</code> <code class="o">&amp;&amp;</code>
        <code class="nb">Number</code><code class="p">.</code><code class="nx">MIN_SAFE_INTEGER</code> <code class="o">&lt;=</code> <code class="nx">n</code> <code class="o">&amp;&amp;</code>
        <code class="nx">n</code> <code class="o">&lt;=</code> <code class="nb">Number</code><code class="p">.</code><code class="nx">MAX_SAFE_INTEGER</code><code class="p">);</code>
<code class="p">}</code></pre><p>For a given value <code class="literal">n</code>, this function first checks whether <code class="literal">n</code> is a number and an integer. If both checks succeed, <code class="literal">n</code> is safe if it is greater than or equal to <code class="literal">MIN_SAFE_INTEGER</code> and less than or equal to <code class="literal">MAX_SAFE_INTEGER</code>.</p></div><div class="sect3" title="Safe results of arithmetic computations"><div class="titlepage"><div><div><h4 class="title" id="_safe_results_of_arithmetic_computations">Safe results of arithmetic computations</h4></div></div></div><p>How can we make sure that results of arithmetic<a id="id1153551" class="indexterm"> computations are correct? For example, the following result is clearly not correct:</a></p><pre class="screen">&gt; 9007199254740990 + 3
9007199254740992</pre><p>We have two safe operands, but an unsafe result:</p><pre class="screen">&gt; Number.isSafeInteger(9007199254740990)
true
&gt; Number.isSafeInteger(3)
true
&gt; Number.isSafeInteger(9007199254740992)
false</pre><p>The following result is also incorrect:</p><pre class="screen">&gt; 9007199254740995 - 10
9007199254740986</pre><p>This time, the result is safe, but one of the operands isn’t:</p><pre class="screen">&gt; Number.isSafeInteger(9007199254740995)
false
&gt; Number.isSafeInteger(10)
true
&gt; Number.isSafeInteger(9007199254740986)
true</pre><p>Therefore, the result of applying an integer operator <code class="literal">op</code> is guaranteed to be correct only if all operands and the result are safe. More formally:</p><pre class="screen">isSafeInteger(a) &amp;&amp; isSafeInteger(b) &amp;&amp; isSafeInteger(a op b)</pre><p>implies that <code class="literal">a op b</code> is a correct result.</p></div></div></div><div class="sect1" title="Converting to Integer"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="converting_to_integer">Converting to Integer</h2></div></div></div><p>In JavaScript, all numbers are floating point.<a id="id1141402" class="indexterm"> Integers are floating-point numbers without a fraction. Converting a number <code class="literal">n</code> to an integer means finding the integer that is “closest” to <code class="literal">n</code> (where the meaning of “closest” depends on how you convert). You have several options for performing this conversion:</a></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
The <code class="literal">Math</code> functions <code class="literal">Math.floor()</code>, <code class="literal">Math.ceil()</code>, and <code class="literal">Math.round()</code> (see <a class="xref" href="http://speakingjs.com/es5/ch11.html#integers_via_math" title="Integers via Math.floor(), Math.ceil(), and Math.round()">Integers via Math.floor(), Math.ceil(), and Math.round()</a>)
</li><li class="listitem">
The custom function <code class="literal">ToInteger()</code> (see <a class="xref" href="http://speakingjs.com/es5/ch11.html#ToInteger" title="Integers via the Custom Function ToInteger()">Integers via the Custom Function ToInteger()</a>)
</li><li class="listitem">
Binary bitwise operators (see <a class="xref" href="http://speakingjs.com/es5/ch11.html#integers_via_bitwise_operators" title="32-bit Integers via Bitwise Operators">32-bit Integers via Bitwise Operators</a>)
</li><li class="listitem">
The global function <code class="literal">parseInt()</code> (see <a class="xref" href="http://speakingjs.com/es5/ch11.html#parseInt" title="Integers via parseInt()">Integers via parseInt()</a>)
</li></ol></div><p>Spoiler: #1 is usually the best choice, #2 and #3 have niche applications, and #4 is OK for parsing strings, but not for converting numbers to integers.</p><div class="sect2" title="Integers via Math.floor(), Math.ceil(), and Math.round()"><div class="titlepage"><div><div><h3 class="title" id="integers_via_math">Integers via Math.floor(), Math.ceil(), and Math.round()</h3></div></div></div><p>The following three functions are usually the best way of converting a number to an integer:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
<code class="literal">Math.floor()</code> converts its argument to the <a id="id1094884" class="indexterm"></a><a id="id1094860" class="indexterm">closest lower integer:
</a></p><pre class="screen">&gt; Math.floor(3.8)
3
&gt; Math.floor(-3.8)
-4</pre></li><li class="listitem"><p class="simpara">
<code class="literal">Math.ceil()</code> converts its argument to the <a id="id533097" class="indexterm"></a><a id="id533103" class="indexterm">closest higher integer:
</a></p><pre class="screen">&gt; Math.ceil(3.2)
4
&gt; Math.ceil(-3.2)
-3</pre></li><li class="listitem"><p class="simpara">
<code class="literal">Math.round()</code> converts its argument to the<a id="id533133" class="indexterm"></a><a id="id1052423" class="indexterm"></a><a id="id1052429" class="indexterm"> closest integer:
</a></p><pre class="screen">&gt; Math.round(3.2)
3
&gt; Math.round(3.5)
4
&gt; Math.round(3.8)
4</pre><p class="simpara">The result of rounding <code class="literal">-3.5</code> may be surprising:</p><pre class="screen">&gt; Math.round(-3.2)
-3
&gt; Math.round(-3.5)
-3
&gt; Math.round(-3.8)
-4</pre><p class="simpara">Therefore, <code class="literal">Math.round(x)</code> is the same as:</p><pre class="programlisting"><code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nx">x</code> <code class="o">+</code> <code class="mf">0.5</code><code class="p">)</code></pre></li></ul></div></div><div class="sect2" title="Integers via the Custom Function ToInteger()"><div class="titlepage"><div><div><h3 class="title" id="ToInteger">Integers via the Custom Function ToInteger()</h3></div></div></div><p>Another good option for converting any value to an integer is the internal ECMAScript operation <code class="literal">ToInteger()</code>, which removes the fraction of a floating-point number.<a id="id1093169" class="indexterm"></a><a id="id1093180" class="indexterm"> If it was accessible in JavaScript, it would work like this:</a></p><pre class="screen">&gt; ToInteger(3.2)
3
&gt; ToInteger(3.5)
3
&gt; ToInteger(3.8)
3
&gt; ToInteger(-3.2)
-3
&gt; ToInteger(-3.5)
-3
&gt; ToInteger(-3.8)
-3</pre><p>The ECMAScript specification defines the result of <code class="literal">ToInteger(number)</code> as:</p><div class="informalequation" style="width: auto"><p>sign(number) × floor(abs(number))</p></div><p>For what it does, this formula is relatively complicated because <code class="literal">floor</code> seeks the closest <span class="emphasis"><em>larger</em></span> integer; if you want to remove the fraction of a negative integer, you have to seek the closest smaller integer.
The following code implements the operation in JavaScript. We avoid the <code class="literal">sign</code> operation by using <code class="literal">ceil</code> if the number is negative:</p><pre class="programlisting"><code class="kd">function</code> <code class="nx">ToInteger</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">x</code> <code class="o">=</code> <code class="nb">Number</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
    <code class="k">return</code> <code class="nx">x</code> <code class="o">&lt;</code> <code class="mi">0</code> <code class="o">?</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">ceil</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">:</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
<code class="p">}</code></pre></div><div class="sect2" title="32-bit Integers via Bitwise Operators"><div class="titlepage"><div><div><h3 class="title" id="integers_via_bitwise_operators"><a id="ToInt32"></a><a id="ToUint32">32-bit Integers via Bitwise Operators</a></h3></div></div></div><p>Binary bitwise operators (see <a class="xref" href="http://speakingjs.com/es5/ch11.html#binary_bitwise_operators" title="Binary Bitwise Operators">Binary Bitwise Operators</a>) convert (at least) one of their operands to a 32-bit integer that is then manipulated to produce a result that is also a 32-bit integer.<a id="id1079945" class="indexterm"></a><a id="bitwiseopsint" class="indexterm"></a><a id="id1079955" class="indexterm"> Therefore, if you choose the other operand appropriately, you get a fast way to convert an arbitrary number to a 32-bit integer (that is either signed or unsigned).</a></p><div class="sect3" title="Bitwise Or (|)"><div class="titlepage"><div><div><h4 class="title" id="_bitwise_or">Bitwise Or (|)</h4></div></div></div><p>If the mask, the second operand, is 0, you don’t change any bits and the result is the first operand, coerced to a signed 32-bit integer. <a id="id1080008" class="indexterm">This is the canonical way to execute this kind of coercion and is used, for example, by asm.js (refer back to </a><a class="xref" href="http://speakingjs.com/es5/ch02.html#asm.js" title="Is JavaScript Fast Enough?">Is JavaScript Fast Enough?</a>):</p><pre class="programlisting"><code class="c1">// Convert x to a signed 32-bit integer</code>
<code class="kd">function</code> <code class="nx">ToInt32</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">x</code> <code class="o">|</code> <code class="mi">0</code><code class="p">;</code>
<code class="p">}</code></pre><p><code class="literal">ToInt32()</code> removes the <a id="id1100226" class="indexterm">fraction and applies modulo 2<sup>32</sup>:</a></p><pre class="screen">&gt; ToInt32(1.001)
1
&gt; ToInt32(1.999)
1
&gt; ToInt32(1)
1
&gt; ToInt32(-1)
-1
&gt; ToInt32(Math.pow(2, 32)+1)
1
&gt; ToInt32(Math.pow(2, 32)-1)
-1</pre></div><div class="sect3" title="Shift operators"><div class="titlepage"><div><div><h4 class="title" id="_shift_operators">Shift operators</h4></div></div></div><p>The same trick that worked for bitwise Or also works for shift operators: if you shift by zero bits, the result of a shift operation is the first operand, coerced to a 32-bit integer.<a id="id1100255" class="indexterm"></a><a id="id1100261" class="indexterm"></a><a id="id1100270" class="indexterm"></a><a id="id1100279" class="indexterm"> Here are some examples of implementing operations of the ECMAScript specification via shift operators:</a></p><pre class="programlisting"><code class="c1">// Convert x to a signed 32-bit integer</code>
<code class="kd">function</code> <code class="nx">ToInt32</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">x</code> <code class="o">&lt;&lt;</code> <code class="mi">0</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// Convert x to a signed 32-bit integer</code>
<code class="kd">function</code> <code class="nx">ToInt32</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">x</code> <code class="o">&gt;&gt;</code> <code class="mi">0</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// Convert x to an unsigned 32-bit integer</code>
<code class="kd">function</code> <code class="nx">ToUint32</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">x</code> <code class="o">&gt;&gt;&gt;</code> <code class="mi">0</code><code class="p">;</code>
<code class="p">}</code></pre><p>Here is <code class="literal">ToUint32()</code> in <a id="id1141292" class="indexterm">action:</a></p><pre class="screen">&gt; ToUint32(-1)
4294967295
&gt; ToUint32(Math.pow(2, 32)-1)
4294967295
&gt; ToUint32(Math.pow(2, 32))
0</pre></div><div class="sect3" title="Should I use bitwise operators to coerce to integer?"><div class="titlepage"><div><div><h4 class="title" id="_should_i_use_bitwise_operators_to_coerce_to_integer">Should I use bitwise operators to coerce to integer?</h4></div></div></div><p>You have to decide for yourself if the slight increase<a id="id1168629" class="indexterm"> in efficiency is worth your code being harder to understand. Also note that bitwise operators artificially limit themselves to 32 bits, which is often neither necessary nor useful. Using one of the <code class="literal">Math</code> functions, possibly in addition to <code class="literal">Math.abs()</code>, is a more self-explanatory and arguably better choice.</a></p></div></div><div class="sect2" title="Integers via parseInt()"><div class="titlepage"><div><div><h3 class="title" id="parseInt">Integers via parseInt()</h3></div></div></div><p>The <code class="literal">parseInt()</code> <a id="id1168641" class="indexterm"></a><a id="id1168649" class="indexterm"></a><a id="id1168655" class="indexterm">function:</a></p><pre class="programlisting"><code class="nb">parseInt</code><code class="p">(</code><code class="nx">str</code><code class="p">,</code> <code class="nx">radix</code><code class="o">?</code><code class="p">)</code></pre><p>parses the string <code class="literal">str</code> (nonstrings are coerced) as an integer. The function ignores leading whitespace and considers as many consecutive legal digits as it can find.</p><div class="sect3" title="The radix"><div class="titlepage"><div><div><h4 class="title" id="_the_radix">The radix</h4></div></div></div><p>The range of the<a id="id1141991" class="indexterm"></a><a id="id572153" class="indexterm"> radix is 2 ≤ <code class="literal">radix</code> ≤ 36.
It determines the base of the number to be parsed. If the radix is greater than 10, letters are used as digits (case-insensitively), in addition to 0–9.</a></p><p>If <code class="literal">radix</code> is missing, then it is assumed to be 10, except if <code class="literal">str</code> begins with “0x” or “0X,” in which case <code class="literal">radix</code> is set to 16 (hexadecimal):</p><pre class="screen">&gt; parseInt('0xA')
10</pre><p>If <code class="literal">radix</code> is already 16, then the hexadecimal prefix is optional:</p><pre class="screen">&gt; parseInt('0xA', 16)
10
&gt; parseInt('A', 16)
10</pre><p>So far I have described the behavior of <code class="literal">parseInt()</code> according to the ECMAScript specification. Additionally, some engines set the radix to 8 if <code class="literal">str</code> starts with a zero:</p><pre class="screen">&gt; parseInt('010')
8
&gt; parseInt('0109')  // ignores digits ≥ 8
8</pre><p>Thus, it is best to always explicitly state the radix, to always call <code class="literal">parseInt()</code> with two arguments.</p><p>Here are a few examples:</p><pre class="screen">&gt; parseInt('')
NaN
&gt; parseInt('zz', 36)
1295
&gt; parseInt('   81', 10)
81

&gt; parseInt('12**', 10)
12
&gt; parseInt('12.34', 10)
12
&gt; parseInt(12.34, 10)
12</pre><p>Don’t use <code class="literal">parseInt()</code> to convert a number to an integer. The last example gives us hope that we might be able to use <code class="literal">parseInt()</code> for converting numbers to integers.<a id="id1095976" class="indexterm"> Alas, here is an example where the conversion is incorrect:</a></p><pre class="screen">&gt; parseInt(1000000000000000000000.5, 10)
1</pre></div><div class="sect3" title="Explanation"><div class="titlepage"><div><div><h4 class="title" id="_explanation">Explanation</h4></div></div></div><p>The argument is first converted to a string:</p><pre class="screen">&gt; String(1000000000000000000000.5)
'1e+21'</pre><p><code class="literal">parseInt</code> doesn’t consider “e” to be an integer digit and thus stops parsing after the 1. Here’s another example:</p><pre class="screen">&gt; parseInt(0.0000008, 10)
8
&gt; String(0.0000008)
'8e-7'</pre></div><div class="sect3" title="Summary"><div class="titlepage"><div><div><h4 class="title" id="_summary">Summary</h4></div></div></div><p><code class="literal">parseInt()</code> shouldn’t be used to convert numbers to integers: coercion to string is an unnecessary detour and even then, the result is not always correct.</p><p><code class="literal">parseInt()</code> <span class="emphasis"><em>is</em></span> useful for parsing strings, but you have to be aware that it stops at the first illegal digit. Parsing strings via <code class="literal">Number()</code> (see <a class="xref" href="http://speakingjs.com/es5/ch11.html#function_number" title="The Function Number">The Function Number</a>) is less forgiving, but may produce nonintegers.</p></div></div></div><div class="sect1" title="Arithmetic Operators"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="arithmetic_operators">Arithmetic Operators</h2></div></div></div><p>The following operators are available for <a id="arithmeticops" class="indexterm"></a><a id="numbersarithmetic" class="indexterm">numbers:</a></p><div class="variablelist"><dl><dt><span class="term">
<code class="literal">number1 + number2</code>
</span></dt><dd><p class="simpara">
Numerical addition, unless either of the operands is a string. Then both operands are converted to strings and concatenated<a id="id1093004" class="indexterm"></a><a id="id1092999" class="indexterm"></a><a id="id1092993" class="indexterm"></a><a id="id1093012" class="indexterm"></a><a id="id1093020" class="indexterm"> (see </a><a class="xref" href="http://speakingjs.com/es5/ch09.html#plus_operator" title="The Plus Operator (+)">The Plus Operator (+)</a>):
</p><pre class="screen">&gt; 3.1 + 4.3
7.4
&gt; 4 + ' messages'
'4 messages'</pre></dd><dt><span class="term">
<code class="literal">number1 - number2</code>
</span></dt><dd>
Subtraction.
</dd><dt><span class="term">
<code class="literal">number1 * number2</code>
</span></dt><dd>
Multiplication.
</dd><dt><span class="term">
<code class="literal">number1 / number2</code>
</span></dt><dd>
Division.
</dd><dt><span class="term">
<code class="literal">number1 % number2</code>
</span></dt><dd><p class="simpara">
Remainder:
</p><pre class="screen">&gt; 9 % 7
2
&gt; -9 % 7
-2</pre><div class="warning" title="Warning" epub:type="warning"><h3 class="title">Warning</h3><p>This operation is not modulo. It returns a value whose sign is the same as the first operand (more details in a moment).</p></div></dd><dt><span class="term">
<code class="literal">-number</code>
</span></dt><dd>
Negates its<a id="id1073950" class="indexterm"> operand.
</a></dd><dt><span class="term">
<code class="literal">+number</code>
</span></dt><dd>
Leaves its operand as is; nonnumbers are converted to a number.
</dd><dt><span class="term">
<code class="literal">++variable</code>, <code class="literal">--variable</code>
</span></dt><dd><p class="simpara">
Returns the current value of the variable after<a id="id537561" class="indexterm"></a><a id="id537565" class="indexterm"> incrementing (or decrementing) it by 1:
</a></p><pre class="screen">&gt; var x = 3;
&gt; ++x
4
&gt; x
4</pre></dd><dt><span class="term">
<code class="literal">variable++</code>, <code class="literal">variable--</code>
</span></dt><dd><p class="simpara">
Increments (or decrements) the value of the variable by 1 and returns it:
</p><pre class="screen">&gt; var x = 3;
&gt; x++
3
&gt; x
4</pre></dd></dl></div><div class="tip" title="Mnemonic: increment (++) and decrement (--) operators"><h3 class="title">Mnemonic: increment (++) and decrement (--) operators</h3><p>The position of the operand can help you remember whether it is returned before or after incrementing (or decrementing) it. If the operand comes before the increment operator, it is returned before incrementing it. If the operand comes after the operator, it is incremented and then returned. (The decrement operator works similarly.)</p></div><div class="sidebar"><div class="sidebar-title">Pitfall: The Remainder Operator (%) Is Not Modulo</div><p>The result of the remainder <a id="id1066738" class="indexterm">operator always has the sign of the first operand (for modulo, it is the sign of the second operand):</a></p><pre class="screen">&gt; -5 % 2
-1</pre><p>That means that the following function does not work:</p><pre class="programlisting"><code class="c1">// Wrong!</code>
<code class="kd">function</code> <code class="nx">isOdd</code><code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">n</code> <code class="o">%</code> <code class="mi">2</code> <code class="o">===</code> <code class="mi">1</code><code class="p">;</code>
<code class="p">}</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">isOdd</code><code class="p">(</code><code class="o">-</code><code class="mi">5</code><code class="p">));</code> <code class="c1">// false</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">isOdd</code><code class="p">(</code><code class="o">-</code><code class="mi">4</code><code class="p">));</code> <code class="c1">// false</code></pre><p>The correct version is:</p><pre class="programlisting"><code class="kd">function</code> <code class="nx">isOdd</code><code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">abs</code><code class="p">(</code><code class="nx">n</code> <code class="o">%</code> <code class="mi">2</code><code class="p">)</code> <code class="o">===</code> <code class="mi">1</code><code class="p">;</code>
<code class="p">}</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">isOdd</code><code class="p">(</code><code class="o">-</code><code class="mi">5</code><code class="p">));</code> <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">isOdd</code><code class="p">(</code><code class="o">-</code><code class="mi">4</code><code class="p">));</code> <code class="c1">// false</code></pre></div><p><a id="id1173178" class="indexterm"></a><a id="id1095334" class="indexterm">
</a></p></div><div class="sect1" title="Bitwise Operators"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="bitwise_operators">Bitwise Operators</h2></div></div></div><p>JavaScript has several bitwise operators that work with 32-bit integers.<a id="id1095372" class="indexterm"></a><a id="id1095368" class="indexterm"> That is, they convert their operands to 32-bit integers and produce a result that is a 32-bit integer. Use cases for these operators include processing binary protocols, special algorithms, etc.</a></p><div class="sect2" title="Background Knowledge"><div class="titlepage"><div><div><h3 class="title" id="_background_knowledge">Background Knowledge</h3></div></div></div><p>This section explains a few concepts that will help you understand bitwise operators.</p><div class="sect3" title="Binary complements"><div class="titlepage"><div><div><h4 class="title" id="_binary_complements">Binary complements</h4></div></div></div><p>Two common ways of computing a binary complement (or inverse) of a binary number are:</p><div class="variablelist"><dl><dt><span class="term">
Ones’ complement
</span></dt><dd><p class="simpara">
You compute the ones’ complement <code class="literal">~x</code> of a number <code class="literal">x</code> by inverting each of the 32 digits. Let’s illustrate the ones’ complement via four-digit numbers. The ones’ complement of <code class="literal">1100</code> is <code class="literal">0011</code>. Adding a number to its ones’ complement results in a number whose digits are all 1:
</p><pre class="screen">1 + ~1 = 0001 + 1110 = 1111</pre></dd><dt><span class="term">
Twos’ complement
</span></dt><dd><p class="simpara">
<a id="id1124052" class="indexterm">The twos’ complement <code class="literal">-x</code> of a number <code class="literal">x</code> is the ones’ complement plus one. Adding a number to its twos’ complement results in <code class="literal">0</code> (ignoring overflow beyond the most significant digit). Here’s an example using four-digit numbers:
</a></p><pre class="screen">1 + -1 = 0001 + 1111 = 0000</pre></dd></dl></div></div><div class="sect3" title="Signed 32-bit integers"><div class="titlepage"><div><div><h4 class="title" id="_signed_32_bit_integers">Signed 32-bit integers</h4></div></div></div><p>32-bit integers don’t have an explicit sign, but you can still encode negative numbers.<a id="id1111817" class="indexterm"></a><a id="id1111808" class="indexterm"></a><a id="id1111818" class="indexterm"> For example, −1 can be encoded as the twos’ complement of 1: adding 1 to the result yields 0 (within 32 bits).
The boundary between positive and negative numbers is fluid; 4294967295 (2<sup>32</sup>−1) and −1 are the same integer here. But you have to decide on a sign when you convert such an integer from or to a JavaScript number, which has an explicit sign as opposed to an implicit one. Therefore, <span class="emphasis"><em>signed 32-bit integers</em></span> are partitioned into two groups:</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
Highest bit is 0: number is zero or positive.
</li><li class="listitem">
Highest bit is 1: number is negative.
</li></ul></div><p>The highest bit is often called the <span class="emphasis"><em>sign bit</em></span>. Accordingly, 4294967295, interpreted as a signed 32-bit integer, becomes −1 when converted to a JavaScript number:</p><pre class="screen">&gt; ToInt32(4294967295)
-1</pre><p><code class="literal">ToInt32()</code> is explained in <a class="xref" href="http://speakingjs.com/es5/ch11.html#integers_via_bitwise_operators" title="32-bit Integers via Bitwise Operators">32-bit Integers via Bitwise Operators</a>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Only the unsigned right shift operator (<code class="literal">&gt;&gt;&gt;</code>) works with unsigned 32-bit integers; all other bitwise operators work with signed 32-bit integers.</p></div></div><div class="sect3" title="Inputting and outputting binary numbers"><div class="titlepage"><div><div><h4 class="title" id="_inputting_and_outputting_binary_numbers">Inputting and outputting binary numbers</h4></div></div></div><p>In the following examples, we work with binary numbers<a id="id1169801" class="indexterm"> via the following two operations:</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
<code class="literal">parseInt(str, 2)</code> (see <a class="xref" href="http://speakingjs.com/es5/ch11.html#parseInt" title="Integers via parseInt()">Integers via parseInt()</a>) parses a string <code class="literal">str</code> in binary notation (base 2).<a id="id1169827" class="indexterm"> For example:
</a></p><pre class="screen">&gt; parseInt('110', 2)
6</pre></li><li class="listitem"><p class="simpara">
<code class="literal">num.toString(2)</code> (see <a class="xref" href="http://speakingjs.com/es5/ch11.html#Number.prototype.toString" title="Number.prototype.toString(radix?)">Number.prototype.toString(radix?)</a>) converts<a id="id551700" class="indexterm"> the number <code class="literal">num</code> to a string in binary notation. For example:
</a></p><pre class="screen">&gt; 6..toString(2)
'110'</pre></li></ul></div></div></div><div class="sect2" title="Bitwise Not Operator"><div class="titlepage"><div><div><h3 class="title" id="_bitwise_not_operator">Bitwise Not Operator</h3></div></div></div><p><code class="literal">~number</code> computes the ones’ complement<a id="id551735" class="indexterm"></a><a id="id551742" class="indexterm"> of <code class="literal">number</code>:</a></p><pre class="screen">&gt; (~parseInt('11111111111111111111111111111111', 2)).toString(2)
'0'</pre></div><div class="sect2" title="Binary Bitwise Operators"><div class="titlepage"><div><div><h3 class="title" id="binary_bitwise_operators">Binary Bitwise Operators</h3></div></div></div><p>JavaScript has three binary bitwise operators:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
<code class="literal">number1 &amp; number2</code> (bitwise And)<a id="id1182653" class="indexterm"></a><a id="id1182662" class="indexterm">:
</a></p><pre class="screen">&gt; (parseInt('11001010', 2) &amp; parseInt('1111', 2)).toString(2)
'1010'</pre></li><li class="listitem"><p class="simpara">
<code class="literal">number1 | number2</code> (bitwise Or)<a id="id1106683" class="indexterm">:
</a></p><pre class="screen">&gt; (parseInt('11001010', 2) | parseInt('1111', 2)).toString(2)
'11001111'</pre></li><li class="listitem"><p class="simpara">
<code class="literal">number1 ^ number2</code> (bitwise Xor; eXclusive Or):
</p><pre class="screen">&gt; (parseInt('11001010', 2) ^ parseInt('1111', 2)).toString(2)
'11000101'</pre></li></ul></div><p>There are two ways to intuitively understand binary bitwise operators:</p><div class="variablelist"><dl><dt><span class="term">
One boolean operation per bit
</span></dt><dd><p class="simpara">
In the following formulas, <code class="literal">n<sub>i</sub></code> means bit <code class="literal">i</code> of number <code class="literal">n</code> interpreted as a boolean (0 is <code class="literal">false</code>, 1 is <code class="literal">true</code>). For example, <code class="literal">2<sub>0</sub></code> is <code class="literal">false</code>; <code class="literal">2<sub>1</sub></code> is <code class="literal">true</code>:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
And: <code class="literal"> result<sub>i</sub> = number1<sub>i</sub> &amp;&amp; number2<sub>i</sub> </code>
</li><li class="listitem">
Or: <code class="literal"> result<sub>i</sub> = number1<sub>i</sub> || number2<sub>i</sub> </code>
</li><li class="listitem"><p class="simpara">
Xor: <code class="literal"> result<sub>i</sub> = number1<sub>i</sub> ^^ number2<sub>i</sub> </code>
</p><p class="simpara">The operator <code class="literal">^^</code> does not exist. If it did, it would work like this (the result is <code class="literal">true</code> if exactly one of the operands is <code class="literal">true</code>):</p><pre class="programlisting"><code class="nx">x</code> <code class="o">^^</code> <code class="nx">y</code> <code class="o">===</code> <code class="p">(</code><code class="nx">x</code> <code class="o">&amp;&amp;</code> <code class="o">!</code><code class="nx">y</code><code class="p">)</code> <code class="o">||</code><code class="err">&nbsp;</code><code class="p">(</code><code class="o">!</code><code class="nx">x</code> <code class="o">&amp;&amp;</code> <code class="nx">y</code><code class="p">)</code></pre></li></ul></div></dd><dt><span class="term">
Changing bits of <code class="literal">number1</code> via <code class="literal">number2</code>
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
And: Keeps only those bits of <code class="literal">number1</code> that are set in <code class="literal">number2</code>. This operation is also called <span class="emphasis"><em>masking</em></span>, with <code class="literal">number2</code> being the <span class="emphasis"><em>mask</em></span>.
</li><li class="listitem">
Or: Sets all bits of <code class="literal">number1</code> that are set in <code class="literal">number2</code> and keeps all other bits unchanged.
</li><li class="listitem">
Xor: Inverts all bits of <code class="literal">number1</code> that are set in <code class="literal">number2</code> and keeps all other bits unchanged.
</li></ul></div></dd></dl></div></div><div class="sect2" title="Bitwise Shift Operators"><div class="titlepage"><div><div><h3 class="title" id="_bitwise_shift_operators">Bitwise Shift Operators</h3></div></div></div><p>JavaScript has three bitwise shift operators: <a id="id1101877" class="indexterm"></a><a id="id1101879" class="indexterm"></a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
<code class="literal">number &lt;&lt; digitCount</code> (left shift): <a id="id1101901" class="indexterm">
</a></p><pre class="screen">&gt; (parseInt('1', 2) &lt;&lt; 1).toString(2)
'10'</pre></li><li class="listitem"><p class="simpara">
<code class="literal">number &gt;&gt; digitCount</code> (signed right shift): <a id="id1122148" class="indexterm">
</a></p><p class="simpara">The 32-bit binary number is interpreted as signed (see the preceding section). When shifting right, the sign is preserved:</p><pre class="screen">&gt; (parseInt('11111111111111111111111111111110', 2) &gt;&gt; 1).toString(2)
'-1'</pre><p class="simpara">We have right-shifted –2.<a id="id1122169" class="indexterm"> The result, –1, is equivalent to a 32-bit integer whose digits are all 1 (the twos’ complement of 1). In other words, a signed right shift by one digit divides both negative and positive integers by two.</a></p></li><li class="listitem"><p class="simpara">
number &gt;&gt;&gt; digitCount` (unsigned right shift):
</p><pre class="screen">&gt; (parseInt('11100', 2) &gt;&gt;&gt; 1).toString(2)
'1110'</pre><p class="simpara">As you can see, this operator shifts in zeros from the left.</p></li></ul></div></div></div><div class="sect1" title="The Function Number"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="function_number">The Function Number</h2></div></div></div><p>The function <code class="literal">Number</code> can be <a id="id540338" class="indexterm">invoked in two ways:</a></p><div class="variablelist"><dl><dt><span class="term">
<code class="literal">Number(value)</code>
</span></dt><dd><p class="simpara">
As a normal function, it converts <code class="literal">value</code> to a primitive number (see <a class="xref" href="http://speakingjs.com/es5/ch11.html#tonumber" title="Converting to Number">Converting to Number</a>):
</p><pre class="screen">&gt; Number('123')
123
&gt; typeof Number(3)  // no change
'number'</pre></dd><dt><span class="term">
<code class="literal">new Number(num)</code>
</span></dt><dd><p class="simpara">
As a constructor, it creates a new instance of <code class="literal">Number</code> (see <a class="xref" href="http://speakingjs.com/es5/ch08.html#wrapper_objects" title="Wrapper Objects for Primitives">Wrapper Objects for Primitives</a>), an object that wraps <code class="literal">num</code> (after converting it to a number). For example:
</p><pre class="screen">&gt; typeof new Number(3)
'object'</pre></dd></dl></div><p>The former invocation is the common one.</p></div><div class="sect1" title="Number Constructor Properties"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_number_constructor_properties">Number Constructor Properties</h2></div></div></div><p>The object <code class="literal">Number</code> has the following properties:</p><div class="variablelist"><dl><dt><span class="term">
<code class="literal">Number.MAX_VALUE</code>
</span></dt><dd><p class="simpara">
The largest positive number that can be represented.<a id="id1058609" class="indexterm"> Internally, all digits of its fraction are ones and the exponent is maximal, at 1023. If you try to increment the exponent by multiplying it by two, the result is the error value <code class="literal">Infinity</code> (see </a><a class="xref" href="http://speakingjs.com/es5/ch11.html#infinity" title="Infinity">Infinity</a>):
</p><pre class="screen">&gt; Number.MAX_VALUE
1.7976931348623157e+308
&gt; Number.MAX_VALUE * 2
Infinity</pre></dd><dt><span class="term">
<code class="literal">Number.MIN_VALUE</code>
</span></dt><dd><p class="simpara">
The smallest representable positive number<a id="id1100881" class="indexterm"> (greater than zero, a tiny fraction):
</a></p><pre class="screen">&gt; Number.MIN_VALUE
5e-324</pre></dd><dt><span class="term">
<code class="literal">Number.NaN</code>
</span></dt><dd>
The same value as the global <code class="literal">NaN</code>.
</dd><dt><span class="term">
<code class="literal">Number.NEGATIVE_INFINITY</code>
</span></dt><dd><p class="simpara">
The same <a id="id561843" class="indexterm"></a><a id="id561852" class="indexterm">value as <code class="literal">-Infinity</code>:
</a></p><pre class="screen">&gt; Number.NEGATIVE_INFINITY === -Infinity
true</pre></dd><dt><span class="term">
<code class="literal">Number.POSITIVE_INFINITY</code>
</span></dt><dd><p class="simpara">
The same <a id="id561888" class="indexterm"></a><a id="id561898" class="indexterm">value as <code class="literal">Infinity</code>:
</a></p><pre class="screen">&gt; Number.POSITIVE_INFINITY === Infinity
true</pre></dd></dl></div></div><div class="sect1" title="Number Prototype Methods"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_number_prototype_methods">Number Prototype Methods</h2></div></div></div><p>All methods of primitive numbers<a id="id1086432" class="indexterm"></a><a id="id1086441" class="indexterm"> are stored in <code class="literal">Number.prototype</code> (see </a><a class="xref" href="http://speakingjs.com/es5/ch08.html#primitive_methods_via_wrappers" title="Primitives Borrow Their Methods from Wrappers">Primitives Borrow Their Methods from Wrappers</a>).</p><div class="sect2" title="Number.prototype.toFixed(fractionDigits?)"><div class="titlepage"><div><div><h3 class="title" id="_number_prototype_tofixed_fractiondigits">Number.prototype.toFixed(fractionDigits?)</h3></div></div></div><p><code class="literal">Number.prototype.toFixed(fractionDigits?)</code> returns <a id="id1086469" class="indexterm">an exponent-free representation of the number, rounded to <code class="literal">fractionDigits</code> digits. If the parameter is omitted, the value 0 is used:</a></p><pre class="screen">&gt; 0.0000003.toFixed(10)
'0.0000003000'
&gt; 0.0000003.toString()
'3e-7'</pre><p>If the number is greater than or equal to 10<sup>21</sup>, then this method works the same as <code class="literal">toString()</code>. You get a number in exponential notation:</p><pre class="screen">&gt; 1234567890123456789012..toFixed()
'1.2345678901234568e+21'
&gt; 1234567890123456789012..toString()
'1.2345678901234568e+21'</pre></div><div class="sect2" title="Number.prototype.toPrecision(precision?)"><div class="titlepage"><div><div><h3 class="title" id="_number_prototype_toprecision_precision">Number.prototype.toPrecision(precision?)</h3></div></div></div><p><code class="literal">Number.prototype.toPrecision(precision?)</code> prunes<a id="id1124349" class="indexterm"> the mantissa to <code class="literal">precision</code> digits before using a conversion algorithm similar to <code class="literal">toString()</code>. If no precision is given, <code class="literal">toString()</code> is used directly:</a></p><pre class="screen">&gt; 1234..toPrecision(3)
'1.23e+3'

&gt; 1234..toPrecision(4)
'1234'

&gt; 1234..toPrecision(5)
'1234.0'

&gt; 1.234.toPrecision(3)
'1.23'</pre><p>You need the exponential notation to display 1234 with a precision of three digits.</p></div><div class="sect2" title="Number.prototype.toString(radix?)"><div class="titlepage"><div><div><h3 class="title" id="Number.prototype.toString">Number.prototype.toString(radix?)</h3></div></div></div><p>For <code class="literal">Number.prototype.toString(radix?)</code>, the parameter <code class="literal">radix</code> indicates the base of the system in which the number is to be displayed.<a id="id1098680" class="indexterm"> The most common radices are 10 (decimal), 2 (binary), and 16 (hexadecimal):</a></p><pre class="screen">&gt; 15..toString(2)
'1111'
&gt; 65535..toString(16)
'ffff'</pre><p>The radix must be at least 2 and at most 36.<a id="id1098696" class="indexterm"> Any radix greater than 10 leads to alphabetical characters being used as digits, which explains the maximum 36, as the Latin alphabet has 26 characters:</a></p><pre class="screen">&gt; 1234567890..toString(36)
'kf12oi'</pre><p>The global function <code class="literal">parseInt</code> (see <a class="xref" href="http://speakingjs.com/es5/ch11.html#parseInt" title="Integers via parseInt()">Integers via parseInt()</a>) allows <a id="id1098715" class="indexterm">you to convert such notations back to a number:</a></p><pre class="screen">&gt; parseInt('kf12oi', 36)
1234567890</pre><div class="sect3" title="Decimal exponential notation"><div class="titlepage"><div><div><h4 class="title" id="_decimal_exponential_notation">Decimal exponential notation</h4></div></div></div><p>For the radix 10, <code class="literal">toString()</code> uses exponential notation (with a single digit before the decimal point) in two cases. First, if there are more than 21 digits before the decimal point of a number:</p><pre class="screen">&gt; 1234567890123456789012
1.2345678901234568e+21
&gt; 123456789012345678901
123456789012345680000</pre><p>Second, if a number starts with <code class="literal">0.</code> followed by more than five zeros and a non-zero digit:</p><pre class="screen">&gt; 0.0000003
3e-7
&gt; 0.000003
0.000003</pre><p>In all other cases, a fixed notation is used.</p></div></div><div class="sect2" title="Number.prototype.toExponential(fractionDigits?)"><div class="titlepage"><div><div><h3 class="title" id="_number_prototype_toexponential_fractiondigits">Number.prototype.toExponential(fractionDigits?)</h3></div></div></div><p><code class="literal">Number.prototype.toExponential(fractionDigits?)</code> forces<a id="id1109661" class="indexterm"></a><a id="id1057459" class="indexterm"> a number to be expressed in exponential notation. <code class="literal">fractionDigits</code> is a number between 0 and 20 that determines how many digits should be shown after the decimal point. If it is omitted, then as many significant digits are included as necessary to uniquely specify the number.</a></p><p>In this example, we force more precision when <code class="literal">toString()</code> would also use exponential notation. Results are mixed, because we reach the limits of the precision that can be achieved when converting binary numbers to a decimal notation:</p><pre class="screen">&gt; 1234567890123456789012..toString()
'1.2345678901234568e+21'

&gt; 1234567890123456789012..toExponential(20)
'1.23456789012345677414e+21'</pre><p>In this example, the magnitude of the number is not large enough for an exponent being displayed by <code class="literal">toString()</code>. However, <code class="literal">toExponential()</code> does display an exponent:</p><pre class="screen">&gt; 1234..toString()
'1234'

&gt; 1234..toExponential(5)
'1.23400e+3'

&gt; 1234..toExponential()
'1.234e+3'</pre><p>In this example, we get exponential notation when the fraction is not small enough:</p><pre class="screen">&gt; 0.003.toString()
'0.003'

&gt; 0.003.toExponential(4)
'3.0000e-3'

&gt; 0.003.toExponential()
'3e-3'</pre></div></div><div class="sect1" title="Functions for Numbers"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="global_number_functions">Functions for Numbers</h2></div></div></div><p>The following functions<a id="id1103289" class="indexterm"> operate on numbers:</a></p><div class="variablelist"><dl><dt><span class="term">
<code class="literal">isFinite(number)</code>
</span></dt><dd>
Checks <a id="id1103316" class="indexterm">whether <code class="literal">number</code> is an actual number (neither <code class="literal">Infinity</code> nor <code class="literal">NaN</code>). For details, see </a><a class="xref" href="http://speakingjs.com/es5/ch11.html#isFinite" title="Checking for Infinity">Checking for Infinity</a>.
</dd><dt><span class="term">
<code class="literal">isNaN(number)</code>
</span></dt><dd>
Returns <code class="literal">true</code> <a id="id1077117" class="indexterm"></a><a id="id1077123" class="indexterm">if <code class="literal">number</code> is <code class="literal">NaN</code>. For details, see </a><a class="xref" href="http://speakingjs.com/es5/ch11.html#isNaN" title="Pitfall: checking whether a value is NaN">Pitfall: checking whether a value is NaN</a>.
</dd><dt><span class="term">
<code class="literal">parseFloat(str)</code>
</span></dt><dd>
Turns <code class="literal">str</code> into a<a id="id1077165" class="indexterm"> floating-point number. For details, see </a><a class="xref" href="http://speakingjs.com/es5/ch11.html#parseFloat" title="parseFloat()">parseFloat()</a>.
</dd><dt><span class="term">
<code class="literal">parseInt(str, radix?)</code>
</span></dt><dd>
Parses <code class="literal">str</code> as <a id="id1063431" class="indexterm">an integer whose base is <code class="literal">radix</code> (2–36). For details, see </a><a class="xref" href="http://speakingjs.com/es5/ch11.html#parseInt" title="Integers via parseInt()">Integers via parseInt()</a>.
</dd></dl></div></div><div class="sect1" title="Sources for This Chapter"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_sources_for_this_chapter">Sources for This Chapter</h2></div></div></div><p>I referred to the following sources while writing this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
<a class="ulink" href="http://bit.ly/1oOc43P" target="_top">“IEEE Standard 754 Floating Point Numbers”</a> by Steve Hollasch
</li><li class="listitem">
<a class="ulink" href="http://bit.ly/1oOc83t" target="_top">“Data Types and Scaling (Fixed-Point Blockset)”</a> in the MATLAB documentation
</li><li class="listitem">
<a class="ulink" href="http://en.wikipedia.org/wiki/IEEE_754" target="_top">“IEEE floating point”</a> on Wikipedia
<a id="id547961" class="indexterm">

</a></li></ul></div></div><div class="footnotes" epub:type="footnotes"><br><hr style="width: 100; align: left;"><div class="footnote" id="ftn.id1121023"><p><sup>[<a href="http://speakingjs.com/es5/ch11.html#id1121023" class="simpara">14</a>] </sup>Source: Brendan Eich, <a class="ulink" href="http://bit.ly/1lKzQeC" target="_top">http://bit.ly/1lKzQeC</a>.</p></div><div class="footnote" epub:type="footnote" id="ftn.id1174193"><p><sup>[<a href="http://speakingjs.com/es5/ch11.html#id1174193" class="simpara">15</a>] </sup>Béla Varga (@netzzwerg) pointed out that IEEE 754 specifies NaN as not equal to itself.</p></div></div></section>


<div class="next-chapter">
    Next: <a href="http://speakingjs.com/es5/ch12.html">12. Strings</a>
</div>


</div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-47067475-1', 'speakingjs.com');
  ga('send', 'pageview');
</script>


</body></html>